---
title: "The Relationship Between Arsenic Concentrations and Well Usage"
author: "Nagaprasad Rudrapatna and Martin Olarte"
header-includes:
   - \usepackage{setspace}
   - \singlespacing
   - \def\bs{\boldsymbol}
fig_width: 6.5
fig_height: 4
df_print: kable
output: pdf_document
fontsize: 12pt
mainfont: Times New Roman
sansfont: Times New Roman
monofont: Times New Roman
indent: true
self_contained: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(rstanarm)
library(magrittr)
library(tidyverse)
library(ggplot2)
library(loo)
library(bayesplot)
library(caret)
library(rstan)
library(HSAUR3)
library(foreign)
library(R2OpenBUGS)
library(arm)
library(kableExtra)
```

### Introduction

Water access and sanitation have been two of the most prominent issues around the world for decades. South Asia, in particular, has been and continues to be among the most severely affected areas. According to UNICEF, "millions have limited access to safe water services" in this region. The challenges associated with water access are among the leading causes of child mortality and morbidity. Moreover, limited access to clean water sources has been linked to undernutrition and declining quality of education for children (UNICEF). In many South Asian nations, the primary source of clean water is tubewells. In Bangladesh, for example, 94.02% of water sources are tubewells$^{1}$ (citation). Unfortunately, many wells used for cooking and drinking (consumption) in Bangladesh and other South Asian countries are contaminated with arsenic. Arsenic is a cumulative poison$^{2} footnote: This refers to the accumulation of a toxic chemical in the human body over a period of time$ that is toxic even in low concentrations. According to one source, arsenic contamination of well sources impacts approximately 100 million South Asians on a daily basis (Gelman, 2007, p. 87). The risks posed by this chemical have been studied extensively, and the World Health Organization (WHO) has issued warnings about potential health consequences: "long-term exposure to arsenic from drinking water and food can cause cancer and skin lesions. It has also been associated with cardiovascular disease and diabetes. In utero and early childhood exposure has been linked to negative impacts on cognitive development and increased deaths in young adults" (citation). Furthermore, we learned that “the rural population of the Bengal Basin will probably continue to rely primarily on tubewells for at least another decade" (Van Geen et al., 2007). This implies that a deeper understanding of the issue is needed and that modeling should focus on predicting the behavior of well users in years to come.

Our analysis is based on a reduced version of the `all` dataset consisting of 6510 observations and 57 variables. Each observation captures characteristics about a household in Araihazar Upazila of Narayanganj District in the Division of Dhaka, Bangladesh. The complete dataset is available on Professor Gelman's (affiliated with Columbia University) website and was last modified in December 2004 (http://www.stat.columbia.edu/~gelman/arm/examples/arsenic/). The data was collected by a research team from the United States and Bangladesh that measured the arsenic concentrations in each well and surveyed households according to a pre-designed questionnaire. It is important to note that the study was not completely objective since “people with unsafe wells were encouraged to switch to nearby private or community wells or to new wells of their own construction" (Gelman, 2007, p. 87). For context, the definition of "unsafe" wells used in that analysis (as well as our own) was based on the Bangladesh standard for arsenic in drinking water, which is below $50\space\mu g/L$ rather than the stricter WHO standard (below $10\space\mu g/L$).

Another critical observation is that "safe and unsafe wells are intermingled in much of the Araihazar Upazila (at least in rural areas). This suggests that users of unsafe wells have the option to switch to nearby safe wells (Gelman, 2007, p. 87). Based on this realization, we can discard modeling options on the basis of spatial locality, like clustering. Since safe and unsafe wells appear to be located in close proximity to each other (intermingled), it would be effectively impossible to partition the area into subregions with only safe or unsafe wells (but not both). It is important to note that the observation regarding the relative positions of safe and unsafe wells is not true in general. In fact, families may not be able to switch wells for a number of reasons - including ones unrelated to the distance to the nearest safe well. In Araihazar Upazila - the region of interest - well ‘switching’ is a feasible alternative given that every household has a safe well nearby, well capacity is large enough for additional users, and other options, like surface water, are subject to contamination by microbes (Gelman, 2007, p. 87). Other studies on water quality have concentrated on similar South Asian regions (Cha et al., 2016), but they primarily focus on estimating the arsenic contamination from other water quality parameters. In this analysis, we use arsenic concentration along with socioeconomic variables of households to predict if a given household will switch from an unsafe well to a safe well.

Accordingly, our response variable is `switch` - a binary value that indicates whether the user of an unsafe well in an area of Araihazar Upazila, Bangladesh switched to a different well. If `switch` takes a value of 1, it indicates that the household switched to a new well; conversely, if `switch` takes a value of 0, the household continued using the current well. The remaining 56 variables are all covariate variables, which contain information about the household and wells in the area. For the purpose of this analysis, we only considered 7 relevant covariates from the available 56 and recoded some of them to remove some inconsistencies and redundancies, while improving interpretability.

Only two of the chosen covariates are continuous variables: `dist` indicates the distance (in meters) to the closest “safe” well, where “safe” is defined as having an arsenic concentration below 50 micrograms per liter. `arsenic` indicates the arsenic concentration (in micrograms per liter) of a household's current well. The remaining covariates are categorical variables: `educ` indicates the education level of the head of the household in years of education completed. `educ4` indicates the education level of the head of the household as a categorical variable with 4 levels: 0, 1-8, 9-12, or 12+ years of education completed. `assoc` indicates if any member of the household is active in community organizations. Originally, the questionnaire had more options to specify the type of organization ([0] no, [1] informal savings/micro-credit, [2] bazaar samiti (i.e. marketplace), [3] other), but the difference between no association and any association was more significant. The precise nature of the organization was deemed irrelevant for developing a model capable of predicting a household’s decision to switch wells. `use` indicates how the household used the well. The questionnaire asked if the well was used for drinking or cooking, but "sometimes" was also an option. Thus, it seemed logical to group the responses into four levels: Unfrequently, Drinking, Cooking, or Both. `status_perceived` indicates how the household perceived the status or condition of the well (Unsafe, Safe, or Don't Know). `well_shift` indicates if the household had shifted to a different well in the past 3 years before the study was conducted.

We shall first fit the model just using distance to nearest well and then put in arsenic concentration, organizational membership, and education.


```{r data}
# Set up cleaned dataset for Bangladesh well-switching

# Read in the data

all <- read.dta ("all.dta", convert.factors=F)

# For simplicity, pull out all wells with missing data in the variables that 
# we will be using in our analysis

# according to well owner's wife/sister-in-law
# survey of laypersons, not scientific experts

missing <- is.na (all[,"func"] + all[,"as"] + all[,"distnearest"] + all[,"assn"]
                  + all[,"ed"] + all[,"ed4"] + all[, "drink"] + all[, "status"]
                  + all[, "change"] + all[, "shifted"])
table(missing)

# with the added predictors, still only 12 missing out of 6510

# recode change and shifted to 0/1

# https://www.ldeo.columbia.edu/~avangeen/publications/documents/vanGeen_JESH_07.pdf

# PREDICTIVE ACCURACY

# try recoding: the levels of education among the 3020 respondents varied from 
# 0 to 18 years, with nearly a third having zero. We repeated our analysis with 
# a discrete recoding of the education variable 
# (0 = 0 years, 1 = 1–8 years, 2 = 9–12 years, 3 = 12+ years), 
# and our results were essentially unchanged. 

# ed4: ed/4 - if ed is not a multiple of 4, ed4 truncates the quotient, 
# e.g. ed = 10, ed4 = 10/4 = 2.5 -> 2 

# perception of well safety; not based on arsenic concentrations 
# (already know that every well in consideration is unsafe) -> see question 6 
# to explain potential biases, source of misinformation

# Include only the wells that are functioning (func==1) - analysis does not 
# consider preferences (switching for no apparent reason related to safety)
# and "unsafe" (as>50) - arsenic concentration micrograms per liter > 50
keep <- all[,"func"]==1 & all[,"as"]>50
attach.all (all[!missing & keep,])

# Give convenient names to the variables

switch <- switch
arsenic <- as 
dist <- distnearest 
assoc <- ifelse (assn > 0, "Yes", "No")
educ <- ed
educ4 <- case_when(ed4 == 0 ~ "0",
                   ed4 == 1 ~ "1-8",
                   ed4 == 2 ~ "9-12",
                   ed4 == 3 ~ "12+")
use <- case_when(drink == 0 ~ "Neither",
                 drink == 1 ~ "Unfrequently",
                 drink == 2 ~ "Drinking",
                 drink == 3 ~ "Cooking",
                 drink == 13 ~ "Cooking",
                 drink == 23 ~ "Both")
status_perceived <- case_when(status == 0 ~ "Unsafe",
                              status == 1 ~ "Safe",
                              status == 2 ~ "Don't Know")
well_shift <- ifelse (shifted == 0, "No", "Yes")

wells.data <- cbind (switch, arsenic, dist, assoc, educ, educ4, use, 
                     status_perceived, well_shift)
write.table (wells.data, "wells.dat")

wells <- read.table("wells.dat", header = TRUE)
df <- data.frame(wells) %>%
  mutate(switch = as.factor(switch),
         assoc = as.factor(assoc),
         educ4 = factor(educ4, levels = c("0", "1-8", "9-12", "12+")),
         use = factor(use, levels = c("Unfrequently", "Drinking", "Cooking", "Both", "Neither")),
         status_perceived = factor(status_perceived, levels = c("Safe", "Unsafe", "Don't Know")),
         well_shift = as.factor(well_shift))

drinkorcook_wells <- wells[wells$use!=0,]
## Stopping point
```

```{r EDA, fig.width = 8, fig.height = 4, echo=FALSE}
# captions

### Continuous Predictors
# Distances 
hist(dist, breaks=seq(0,10+max(dist[!is.na(dist)]),10), 
     xlab="Distance (m) to nearest safe well", ylab="Frequency", 
     main="Distance to Wells")
wells %>%
  summarise(min = min(dist),
            max = max(dist),
            mean = mean(dist), 
            sd = sd(dist), 
            median = median(dist), 
            IQR = IQR(dist)) %>%
  kable(digits = 3)

ggplot(data = df, mapping = aes(x = dist, fill = switch)) +
  geom_density(alpha = 0.6) + labs(x  = "Distance (m) to nearest safe well", y = "Density", 
       title = "Distance to Wells")
    
# Arsenic 
hist(arsenic, breaks=seq(0,100+max(arsenic[!is.na(arsenic)]),50), 
     xlab="Arsenic Content (micrograms per liter)", ylab="Frequency", main="Arsenic Content")
wells %>%
  summarise(min = min(arsenic),
            max = max(arsenic),
            mean = mean(arsenic), 
            sd = sd(arsenic), 
            median = median(arsenic), 
            IQR = IQR(arsenic)) %>%
  kable(digits = 3)

ggplot(data = df, mapping = aes(x = arsenic, fill = switch)) +
  geom_density(alpha = 0.6) +
  labs(x  = "Arsenic Content (micrograms per liter)", y = "Density", 
       title = "Arsenic Content")
    
### Discrete Predictors
# Education 
hist(educ, breaks=seq(0,5+max(educ[!is.na(educ)]),5), xlab="Years of Education",
     ylab="Frequency", main="Education")
wells %>%
  summarise(min = min(educ),
            max = max(educ),
            mean = mean(educ), 
            sd = sd(educ), 
            median = median(educ), 
            IQR = IQR(educ)) %>%
  kable(digits = 3)
ggplot(data = df, mapping = aes(x = educ, fill = switch)) +
  geom_histogram(binwidth = 1) +
  labs(x  = "Years of Education", y = "Frequency", 
       title = "Education")
# Education (Recoded)
ggplot(data = df, mapping = aes(x = educ4, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Years of Education", y = "Frequency", 
       title = "Education (Recoded)")

# Community Association
ggplot(data = df, mapping = aes(x = assoc, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Community Association", y = "Frequency", 
       title = "Community Association")
# Use
ggplot(data = df, mapping = aes(x = use, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Well Use", y = "Frequency", 
       title = "Well Use")

# Perceived Status
ggplot(data = df, mapping = aes(x = status_perceived, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Perceived Status", y = "Frequency", 
       title = "Perceived Status")

# Shift
ggplot(data = df, mapping = aes(x = well_shift, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Well Shift (Last 3 Years)", y = "Frequency", 
       title = "Well Shift (Last 3 Years)")

### Response Variable
ggplot(data = df, mapping = aes(x = switch)) +
  geom_bar(fill = "dark green") + 
  labs (x = "Well Switch*", y = "Frequency",
        caption = "*0 = No,  1 = Yes",
        title = "Well Switch (Response)")


### Interactions

ggplot(data = df, mapping = aes(x = dist, fill = use)) +
  geom_density(alpha = 0.3) + labs(x  = "Distance (m) to nearest safe well", y = "Density", 
       title = "Distance to Wells vs Well Use")
ggplot(data = df, mapping = aes(x = dist, fill = status_perceived)) +
  geom_density(alpha = 0.6) + labs(x  = "Distance (m) to nearest safe well", y = "Density", 
       title = "Distance to Wells vs Perceived Status")
ggplot(data = df, mapping = aes(x = dist, fill = well_shift)) +
  geom_density(alpha = 0.6) + labs(x  = "Distance (m) to nearest safe well", y = "Density", 
       title = "Distance to Wells vs Well Shift")

ggplot(data = df, mapping = aes(x = arsenic, fill = use)) +
  geom_density(alpha = 0.6) + labs(x  = "Arsenic Content (micrograms per liter)", y = "Density", 
       title = "Arsenic Content vs Well Use")

ggplot(data = df, mapping = aes(x = arsenic, y = dist)) +
  geom_point() + labs(x  = "Arsenic Content (micrograms per liter)", y = "Distance (m) to nearest safe well", 
       title = "Arsenic Content vs Distance to Wells")
```

All observations that were included in this analysis had the arsenic concentration of their well above the Bangladesh standard of $50\space\mu g/L$. The maximum was nearly 20 times the safe concentration threshold ($965\space\mu g/L$), which highlights the urgency of the issue that needs to be addressed. Initially, it seems that arsenic content is less of a significant predictor than perceived well status and distance to nearest safe well, but interactions with other predictors are intuitively reasonable; perhaps households decide whether to switch their well based on a combination of perceptions and science, or perhaps wells that are far from the nearest safe well are also likely to be particularly high in arsenic. 

The relative proportions of switch to no switch seem consistent regardless of community association, which suggests community association is not the most important predictor. However, community association should still be included in the initial model before any model selection to confirm our EDA observations are supported. 

The years of education vary greatly among households; majority either have no formal education or five years. The fact that some of the levels have limited observations makes it increasingly difficult to determine if there is a significant effect, which motivated the recoding of the education variable into 4 levels. As expected, 0 years is still most frequent, but now we can argue that the overall population of interest has between 0-12 years of education (up to high school) and anything beyond (tertiary education) seems to be a luxury. Moreover, from *FIGURE NUMBER* it is evident that among those who have completed more than 12 years of education, most did not choose to switch. This decision could be influenced however by the fact that most of those households also do not use the water from the well for drinking or cooking, but this relationship needs to be investigated further. The vast majority of households use wells for both drinking and cooking, or neither; those who do not use wells for drinking and cooking, as expected, responded they would switch most frequently.

The univariate distribution of distances confirms our initial suspicions about the proximity of safe and unsafe wells. Summary statistics indicate that the maximum distance to the nearest safe well is 339.531 meters (which is reasonable for daily round trips (double distance); assume speed 1 m/s, then roughly 340 s ~ 5.7 min) and the average distance is 48.332 m. From *FIGURE NUMBER*, it is evident that the densities do not exactly align, which supports the claim that the distance to the nearest safe well is not the only significant covariate. There is a noticeable difference in the propensity of households to switch when the distance to the nearest safe well is between 0-200 m (switching occurs with greatest probability when distance to nearest safe well is between 0-50 m), and at the tails (i.e. when the distance exceeds approximately 230 m), the densities overlap.

Based on the plot of well shift in the last 3 years and the response (*FIGURE NUMBER*), there is evidence in the data suggesting that this covariate should be significant in the logistic regression model; note that all of the households which shifted to a different well in the past three years, expected to switch once more when informed about the unsafe well.

Similarly, based on the plot of perceived well status and the response (*FIGURE NUMBER*), there is evidence in the data suggesting that this covariate should be significant in the logistic regression model (there are seemingly significant differences, at least visually, among levels of predictor); note that a significant proportion of households who believed the well to be unsafe, still chose not to switch.

# Modeling 

It seems more reasonable to rescale distance in 100-meter units since the regression coefficient associated with a 1-meter change in distance to the nearest safe well can be misleading. The coefficient could, for instance, correspond to the difference between a house located 100 meters away from the nearest safe well and a house located 101 meters away (a negligible difference in practice).

Before fitting interactions, it makes sense to mean-center the continuous main effects so that we can more easily interpret the coefficients. We do not fully standardize these — that is, we do not scale by their standard deviations — because it is convenient to be able to consider known differences on the original scales of the data (100-meter distances and arsenic-concentration units).

Now, we will provide a more technical description of our modeling framework. We have identified a binary response variable. In order to select an appropriate sampling model (Bayesian Generalized Linear Model), we need to consider the structure of the data. Specifically, we contemplated three options for the link function: logit, complementary-log-log (cloglog), and inverse-c.d.f of the standard normal distribution. Initially, we suspected that the binary response variable `switch` might be highly unbalanced since well ‘switching’ is contingent upon a number of factors. The visualization of the response reveals that, while there are lots of 0’s (i.e. many households choose not to switch to safe wells), there are more 1’s (i.e. even more households choose to switch to safe wells).The cloglog link function is preferable when the response is highly unbalanced, so we decided that it was not appropriate in this instance. While we suspected that the cloglog link may be applicable, the same cannot be said about the link function in probit regression (inverse-c.d.f of the standard normal distribution). Probit regression is appropriate when there is reason to believe that the binary response is generated from a latent Normal random variable. While we did not see anything in the EDA to suggest such a process, it is possible. However, we decided to use the familiar logit link function since our objective is prediction. It is well-known that probit and logistic regression models generate similar levels of predictive accuracy; therefore, using a model which assumes a latent structure (that we have no evidence of) is unnecessary.

Let $Y$ be the binary response variable (`switch`), $\bs x$ be the vector of covariates in the regression model, and $\bs \beta$ be the vector of regression coefficients associated with the covariates.

  - Probability model: $[Y \mid \theta] \sim \text{Bernoulli}(\theta)$

  - Link function: $g(\theta)=\text{logit}(\theta)=\eta$ 

  - Systematic component: $\eta = \bs x^T \bs \beta$

By applying the inverse $\text{logit}$ function to both sides of the link function (which yields $\theta = \text{logit}^{-1}(\eta)$), the sampling model can be written as: 

$$
Y \mid \bs \beta \sim \text{logit}^{-1}(\bs x^T \bs \beta)
$$
We found that placing independent student t-distribution priors on the regression coefficients (for the covariates and intercept term) is appropriate when developing data-driven (weakly-informative prior) logistic regression models. Specifically, we decided to use student t-distributions with 7 degrees of freedom and a scale of 2.5 (prior mean 0). These hyperparameters were chosen after considering the null logistic regression model, i.e. intercept-only model. Gellman and colleagues explain that this baseline case (one-half of a success and one-half of a failure for a single Binomial trial with probability $p=\text{logit}^{-1}(\theta)$) has a corresponding likelihood of $\text{e}^{\theta/2} / (1+e^{\theta})$ and further that the density function associated with the student t-distribution (with 7 degrees of freedom and scale 2.5) is a reasonable approximation. Importantly, this choice of prior distribution assumes that the regression coefficients will be small. However, the coefficients have a non-zero probability of being relatively large. It is appropriate to use this weakly-informative prior distribution because the objective is to develop a data-driven model with high predictive accuracy (and we did not find any context-specific information which would restrict the prior distribution). So, the prior specification is:

$$
\beta \sim t_{7}
$$
Our modeling strategy includes a single round of model selection. We perform backward selection using `looic` (leave-one-out) criterion on the model including the intercept term, main effects, and interaction terms. We considered performing two rounds of model selection - first for the model with only the intercept term and main effects and then for the optimal model from the first stage along with interaction terms. Our EDA identified several potentially significant interaction terms. In the second model selection strategy, some of these terms would be excluded by default since the corresponding main effects would not be included in the optimal model from the first stage of selection. Hence, we proceeded with a single, comprehensive round of backward selection.

- Main effects: dist100, arsenic, educ4, assoc, use, status_perceived, well_shift
- Interaction terms: arsenic:status_perceived, arsenic:dist, educ4:use, dist100:use, dist100:status_perceived, well_shift:dist100, status_perceived:use, status_perceived:educ4

Interaction terms with `educ4` are excluded by default since `educ4` was eliminated from the logistic regression model during the first stage of model selection.

```{r, echo=FALSE}

# Andrew Gelman, Aleks Jakulin, Maria Grazia Pittau and Yu-Sung Su. (2009). “A Weakly Informative Default Prior Distribution For Logistic And Other Regression Models.” The Annals of Applied Statistics 2 (4): 1360--1383. http://www.stat.columbia.edu/~gelman/research/published/priors11.pdf

# Scaling & Centering
wells$dist100 <- wells$dist/100
wells$as100 <- wells$arsenic/100

wells$dist100 <- scale(wells$dist100, scale = FALSE)
wells$as100 <- scale(wells$as100, scale = FALSE)


seed <- 200

t <- student_t(df = 7, location = 0, scale = 2.5)

main_effects1 <- stan_glm(switch ~ dist100 + as100 + educ4 + assoc + use + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_main1 <- loo(main_effects1, save_psis = TRUE))

no_educ1 <- stan_glm(switch ~ dist100 + as100 + assoc + use + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ1 <- loo(no_educ1, save_psis = TRUE))

no_arsenic_m <- stan_glm(switch ~ dist100 + educ4 + assoc + use + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_arsenic <- loo(no_arsenic_m, save_psis = TRUE))

no_assoc_m <- stan_glm(switch ~ dist100 + arsenic + educ4 + use + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_assoc <- loo(no_assoc_m, save_psis = TRUE))

no_use_m <- stan_glm(switch ~ dist100 + arsenic + educ4 + assoc + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_use <- loo(no_use_m, save_psis = TRUE))

no_status_perceived_m <- stan_glm(switch ~ dist100 + arsenic + educ4 + assoc + use + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_status <- loo(no_status_perceived_m, save_psis = TRUE))

no_well_shift_m <- stan_glm(switch ~ dist100 + arsenic + educ4 + assoc + use + status_perceived, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_shift <- loo(no_well_shift_m, save_psis = TRUE))

loo_compare(loo_main1, loo_no_educ1, loo_no_arsenic, loo_no_assoc, loo_no_use, loo_no_status, loo_no_shift)

############################### FIRST STEP

no_educ_dist <- stan_glm(switch ~ as100 + assoc + use + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_dist <- loo(no_educ_dist, save_psis = TRUE))

no_educ_as <- stan_glm(switch ~ dist100 + assoc + use + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_as <- loo(no_educ_as, save_psis = TRUE))

no_educ_assoc <- stan_glm(switch ~ dist100 + as100 + use + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_assoc <- loo(no_educ_assoc, save_psis = TRUE))

no_educ_use <- stan_glm(switch ~ dist100 + as100 + assoc + status_perceived + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_use <- loo(no_educ_use, save_psis = TRUE))

no_educ_status <- stan_glm(switch ~ dist100 + as100 + assoc + use + well_shift, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_status <- loo(no_educ_status, save_psis = TRUE))

no_educ_shift <- stan_glm(switch ~ dist100 + as100 + assoc + use + status_perceived, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_shift <- loo(no_educ_shift, save_psis = TRUE))

loo_compare(loo_no_educ1, loo_no_educ_dist, loo_no_educ_as, loo_no_educ_assoc, loo_no_educ_use, loo_no_educ_status, loo_no_educ_shift)


################# SECOND STEP
no_educ_interac <- stan_glm(switch ~ dist100 + arsenic + assoc + status_perceived + well_shift + arsenic*status_perceived + arsenic*dist100 + dist100*status_perceived + well_shift*dist100, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_interac <- loo(no_educ_interac, save_psis = TRUE))

no_educ_interac_noassta <- stan_glm(switch ~ dist100 + arsenic + assoc + status_perceived + well_shift + arsenic*dist100 + dist100*status_perceived + well_shift*dist100, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_interac_noassta <- loo(no_educ_interac_noassta, save_psis = TRUE))

no_educ_interac_noasdist <- stan_glm(switch ~ dist100 + arsenic + assoc + status_perceived + well_shift + arsenic*status_perceived + dist100*status_perceived + well_shift*dist100, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_interac_noasdist <- loo(no_educ_interac_noasdist, save_psis = TRUE))

no_educ_interac_nodistshift <- stan_glm(switch ~ dist100 + arsenic + assoc + status_perceived + well_shift + arsenic*status_perceived + arsenic*dist100 + dist100*status_perceived, data = wells,
                 family = binomial(link = "logit"), 
                 prior = t, prior_intercept = t,
                 seed = seed,
                 refresh = 0)
(loo_no_educ_interac_nodistshift <- loo(no_educ_interac_nodistshift, save_psis = TRUE))

loo_compare(loo_no_educ_interac, loo_no_educ_interac_noassta, loo_no_educ_interac_noasdist, loo_no_educ_interac_nodistshift)

#Below, we compute posterior predictive probabilities of the linear predictor via the `posterior_linpred()` function provided in the `rstanarm` package. This function will extract posterior draws from the linear predictor. If we used a link function, then specifying the transform argument as `TRUE` will return the predictor as transformed via the inverse-link.

preds <- posterior_epred(no_educ_interac_noassta)
pred <- colMeans(preds)
pr <- as.integer(pred >= 0.5)

#We calculate these posterior predictive probabilities in order to determine the classification accuracy of our model. If the posterior probability of success for an individual is greater or equal to $0.5$, then we would predict that observation to be a success (and similarly for less than $0.5$). For each observation, we can compare the posterior prediction to the actual observed value. The proportion of times we correctly predict an individual (i.e. [prediction = 0 and observation = 0] or [prediction = 1 and observation = 1]) is our classification accuracy.

round(mean(xor(pr,as.integer(wells$switch==0))),3)


#However, we should really be evaluating the classification accuracy of our model on unseen data. This can be done via a LOOCV approach or by using a test dataset. Here we use the former approach to illustrate the function `E_loo()`, which uses importance weights generated from the `loo()` function.


ploo=E_loo(preds, loo_no_educ_interac_noassta$psis_object, type="mean", log_ratios = -log_lik(no_educ_interac_noassta))$value
round(mean(xor(ploo>0.5,as.integer(wells$switch==0))),3)

#ploo = 0.655 no education, no arsenic*status interaction

#NEXT
preds <- posterior_epred(no_educ_interac)
pred <- colMeans(preds)
pr <- as.integer(pred >= 0.5)

ploo=E_loo(preds, loo_no_educ_interac_noassta$psis_object, type="mean", log_ratios = -log_lik(no_educ_interac))$value
round(mean(xor(ploo>0.5,as.integer(wells$switch==0))),3)

#ploo = XXX no education, all interactions

#NEXT
preds <- posterior_epred(no_educ_interac_noasdist)
pred <- colMeans(preds)
pr <- as.integer(pred >= 0.5)

ploo=E_loo(preds, loo_no_educ_interac_noassta$psis_object, type="mean", log_ratios = -log_lik(no_educ_interac_noasdist))$value
round(mean(xor(ploo>0.5,as.integer(wells$switch==0))),3)

#ploo = XXX no education, no arsenic*distance

#NEXT
preds <- posterior_epred(no_educ_interac_nodistshift)
pred <- colMeans(preds)
pr <- as.integer(pred >= 0.5)

ploo=E_loo(preds, loo_no_educ_interac_noassta$psis_object, type="mean", log_ratios = -log_lik(no_educ_interac_nodistshift))$value
round(mean(xor(ploo>0.5,as.integer(wells$switch==0))),3)

#ploo = XXX no education, no distance*shift interaction

```

```{r}
# Redefine distance in 100-meter units and fit the model again

dist100 <- dist/100
fit.2 <- stan_glm(switch ~ dist100, data = wells,
                 family = binomial(link = "logit"), 
                 prior = normal(0,1), prior_intercept = normal(0,1),
                 seed = seed,
                 refresh = 0)

print(fit.2$stanfit)

### END OF EDITED CODE

# plots of model fit

jitter.binary <- function(a, jitt=.05){
  a + (1-2*a)*runif(length(a),0,jitt)
}

#postscript ("c:/books/multilevel/arsenic.logitfit.1new.a.ps", height=3.5, width=4, horizontal=TRUE)
#plot(c(0,max(dist, na.rm=TRUE)*1.02), c(0,1), xlab="Distance (in meters) to nearest safe well", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
#curve (invlogit(coef(fit.1)[1]+coef(fit.1)[2]*x), lwd=1, add=TRUE)
#points (dist, jitter.binary(switch), pch=20, cex=.1)
#dev.off ()

# histogram of As levels

#postscript ("c:/books/multilevel/arsenic.levels.a.ps", height=3, width=4, horizontal=TRUE)
hist (arsenic, breaks=seq(0,.25+max(arsenic[!is.na(arsenic)]),.25), freq=TRUE, xlab="Arsenic concentration in well water", ylab="", main="", mgp=c(2,.5,0))
#dev.off ()

# model with 2 predictors

fit.3 <- glm (switch ~ dist100 + arsenic, family=binomial(link="logit"))
display (fit.3)

#postscript ("c:/books/multilevel/arsenic.2variables.a.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(dist,na.rm=TRUE)*1.02), c(0,1), xlab="Distance (in meters) to nearest safe well", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (dist, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.3)[1]+coef(fit.3)[2]*x/100+coef(fit.3)[3]*.50), lwd=.5, add=TRUE)
curve (invlogit(coef(fit.3)[1]+coef(fit.3)[2]*x/100+coef(fit.3)[3]*1.00), lwd=.5, add=TRUE)
text (50, .27, "if As = 0.5", adj=0, cex=.8)
text (75, .50, "if As = 1.0", adj=0, cex=.8)
#dev.off ()

#postscript ("c:/books/multilevel/arsenic.2variables.b.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(arsenic,na.rm=TRUE)*1.02), c(0,1), xlab="Arsenic concentration in well water", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (arsenic, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.3)[1]+coef(fit.3)[2]*0+coef(fit.3)[3]*x), from=0.5, lwd=.5, add=TRUE)
curve (invlogit(coef(fit.3)[1]+coef(fit.3)[2]*0.5+coef(fit.3)[3]*x), from=0.5, lwd=.5, add=TRUE)
text (50, .78, "if dist = 0", adj=0, cex=.8)
text (200, .6, "if dist = 50", adj=0, cex=.8)
#dev.off ()

# including an interaction

fit.4 <- glm (switch ~ dist100 + arsenic + dist100:arsenic,
  family=binomial(link="logit"))

# centering the input variables

c.dist100 <- dist100 - mean (dist100)
c.arsenic <- arsenic - mean (arsenic)

fit.5 <- glm (switch ~ c.dist100 + c.arsenic + c.dist100:c.arsenic,
  family=binomial(link="logit"))

#postscript ("c:/books/multilevel/arsenic.interact.a.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(dist,na.rm=TRUE)*1.02), c(0,1), xlab="Distance (in meters) to nearest safe well", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (dist, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.4)[1]+coef(fit.4)[2]*x/100+coef(fit.4)[3]*.50+coef(fit.4)[4]*(x/100)*.50), lwd=.5, add=TRUE)
curve (invlogit(coef(fit.4)[1]+coef(fit.4)[2]*x/100+coef(fit.4)[3]*1.00+coef(fit.4)[4]*(x/100)*1.00), lwd=.5, add=TRUE)
text (50, .29, "if As = 0.5", adj=0, cex=.8)
text (75, .50, "if As = 1.0", adj=0, cex=.8)
#dev.off ()

#postscript ("c:/books/multilevel/arsenic.interact.b.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(arsenic,na.rm=TRUE)*1.02), c(0,1), xlab="Arsenic concentration in well water", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (arsenic, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.4)[1]+coef(fit.4)[2]*0+coef(fit.4)[3]*x+coef(fit.4)[4]*0*x), from=0.5, lwd=.5, add=TRUE)
curve (invlogit(coef(fit.4)[1]+coef(fit.4)[2]*0.5+coef(fit.4)[3]*x+coef(fit.4)[4]*0.5*x), from=0.5, lwd=.5, add=TRUE)
text (.50, .78, "if dist = 0", adj=0, cex=.8)
text (2.00, .6, "if dist = 50", adj=0, cex=.8)
#dev.off ()

# adding social predictors

educ4 <- educ/4

fit.6 <- glm (switch ~ c.dist100 + c.arsenic + c.dist100:c.arsenic +
  assoc + educ4, family=binomial(link="logit"))
display (fit.6)

fit.7 <- glm (switch ~ c.dist100 + c.arsenic + c.dist100:c.arsenic +
  educ4, family=binomial(link="logit"))
display (fit.7)

c.educ4 <- educ4 - mean(educ4)

fit.8 <- glm (switch ~ c.dist100 + c.arsenic + c.educ4 + c.dist100:c.arsenic +
  c.dist100:c.educ4 + c.arsenic:c.educ4, family=binomial(link="logit"))
display (fit.8)

# plots of residuals

pred.8 <- fit.8$fitted.values

#postscript ("c:/books/multilevel/arsenic.logitresidsa.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,1), c(-1,1), xlab="Estimated  Pr (switching)", ylab="Observed - estimated", type="n", main="Residual plot", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
points (pred.8, switch-pred.8, pch=20, cex=.2)
#dev.off ()

binned.resids <- function (x, y, nclass=sqrt(length(x))){
  breaks.index <- floor(length(x)*(1:(nclass-1))/nclass)
  breaks <- c (-Inf, sort(x)[breaks.index], Inf)
  output <- NULL
  xbreaks <- NULL
  x.binned <- as.numeric (cut (x, breaks))
  for (i in 1:nclass){
    items <- (1:length(x))[x.binned==i]
    x.range <- range(x[items])
    xbar <- mean(x[items])
    ybar <- mean(y[items])
    n <- length(items)
    sdev <- sd(y[items])
    output <- rbind (output, c(xbar, ybar, n, x.range, 2*sdev/sqrt(n)))
  }
  colnames (output) <- c ("xbar", "ybar", "n", "x.lo", "x.hi", "2se")
  return (list (binned=output, xbreaks=xbreaks))
}

#postscript ("c:/books/multilevel/arsenic.logitresidsb.ps", height=3.5, width=4, horizontal=TRUE)
br.8 <- binned.resids (pred.8, switch-pred.8, nclass=40)$binned
plot(range(br.8[,1]), range(br.8[,2],br.8[,6],-br.8[,6]), xlab="Estimated  Pr (switching)", ylab="Average residual", type="n", main="Binned residual plot", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
lines (br.8[,1], br.8[,6], col="gray", lwd=.5)
lines (br.8[,1], -br.8[,6], col="gray", lwd=.5)
points (br.8[,1], br.8[,2], pch=20, cex=.5)
#dev.off ()

# compute error rates

error.rate <- mean(round(abs(switch-pred.8)))
error.rate.null <- mean(round(abs(switch-mean(pred.8))))

# more residual plots

#postscript ("c:/books/multilevel/arsenic.logitresids.2a.ps", height=3.5, width=4, horizontal=TRUE)
br <- binned.resids (dist, switch-pred.8, nclass=40)$binned
plot(range(br[,1]), range(br[,2],br[,6],-br[,6]), xlab="Distance to nearest safe well", ylab="Average residual", type="n", main="Binned residual plot", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
n.within.bin <- length(y)/nrow(br)
lines (br[,1], br[,6], col="gray", lwd=.5)
lines (br[,1], -br[,6], col="gray", lwd=.5)
points (br[,1], br[,2], pch=20, cex=.5)
#dev.off ()

#postscript ("c:/books/multilevel/arsenic.logitresids.2b.ps", height=3.5, width=4, horizontal=TRUE)
br <- binned.resids (arsenic, switch-pred.8, nclass=40)$binned
plot(range(0,br[,1]), range(br[,2],br[,6],-br[,6]), xlab="Arsenic level", ylab="Average residual", type="n", main="Binned residual plot", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
lines (br[,1], br[,6], col="gray", lwd=.5)
lines (br[,1], -br[,6], col="gray", lwd=.5)
points (br[,1], br[,2], pch=20, cex=.5)
#dev.off ()

# new model on log scale

log.arsenic <- log (arsenic)
c.log.arsenic <- log.arsenic - mean (log.arsenic)

fit.9 <- glm (switch ~ c.dist100 + c.log.arsenic + c.educ4 +
  c.dist100:c.log.arsenic + c.dist100:c.educ4 + c.log.arsenic:c.educ4,
  family=binomial(link="logit"))
display (fit.9)

fit.9a <- glm (switch ~ dist100 + log.arsenic + educ4 +
  dist100:log.arsenic + dist100:educ4 + log.arsenic:educ4,
  family=binomial(link="logit"))

# graphs for log model

#postscript ("c:/multilevel/arsenic.logmodel.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(arsenic,na.rm=TRUE)*1.02), c(0,1), xlab="Arsenic concentration in well water", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (arsenic, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.9a)[1]+coef(fit.9a)[2]*0+coef(fit.9a)[3]*log(x)+coef(fit.9a)[4]*mean(educ4)+coef(fit.9a)[5]*0*log(x)+coef(fit.9a)[6]*0*mean(educ4)+coef(fit.9a)[7]*log(x)*mean(educ4)), from=.50, lwd=.5, add=TRUE)
curve (invlogit(coef(fit.9a)[1]+coef(fit.9a)[2]*.5+coef(fit.9a)[3]*log(x)+coef(fit.9a)[4]*mean(educ4)+coef(fit.9a)[5]*.5*log(x)+coef(fit.9a)[6]*.5*mean(educ4)+coef(fit.9a)[7]*log(x)*mean(educ4)), from=.50, lwd=.5, add=TRUE)
text (.25, .80, "if dist = 0", adj=0, cex=.8)
text (2.00, .63, "if dist = 50", adj=0, cex=.8)
#dev.off ()

pred.9 <- fit.9$fitted.values

#postscript ("c:/books/multilevel/arsenic.logitresids.3b.ps", height=3.5, width=4, horizontal=TRUE)
br <- binned.resids (arsenic, switch-pred.9, nclass=40)$binned
plot(range(0,br[,1]), range(br[,2],br[,6],-br[,6]), xlab="Arsenic level", ylab="Average residual", type="n", main="Binned residual plot\nfor model with log (arsenic)", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
n.within.bin <- length(y)/nrow(br)
lines (br[,1], br[,6], col="gray", lwd=.5)
lines (br[,1], -br[,6], col="gray", lwd=.5)
points (br[,1], br[,2], pch=20, cex=.5)
#dev.off ()

# calculations for average predictive differences

# simple model
fit.10 <- glm (switch ~ dist100 + arsenic + educ4,
  family=binomial(link="logit"))
display (fit.10)

# avg pred diffs for distance to nearest safe well
b <- coef (fit.10)
hi <- 1
lo <- 0
delta <- invlogit (b[1] + b[2]*hi + b[3]*arsenic + b[4]*educ4) -
         invlogit (b[1] + b[2]*lo + b[3]*arsenic + b[4]*educ4)
print (mean(delta))

# avg pred diffs for arsenic level
hi <- 1.0
lo <- 0.5
delta <- invlogit (b[1] + b[2]*dist100 + b[3]*hi + b[4]*educ4) -
         invlogit (b[1] + b[2]*dist100 + b[3]*lo + b[4]*educ4)
print (mean(delta))

# avg pred diffs for education
hi <- 3
lo <- 0
delta <- invlogit (b[1]+b[2]*dist100+b[3]*arsenic+b[4]*hi) -
         invlogit (b[1]+b[2]*dist100+b[3]*arsenic+b[4]*lo)
print (mean(delta))

# example model with interaction
fit.11 <- glm (switch ~ dist100 + arsenic + educ4 + dist100:arsenic,
  family=binomial(link="logit"))
display (fit.11)

b <- coef (fit.11)
hi <- 1
lo <- 0
delta <- invlogit (b[1] + b[2]*hi + b[3]*arsenic + b[4]*educ4 +
                   b[5]*hi*arsenic) -
         invlogit (b[1] + b[2]*lo + b[3]*arsenic + b[4]*educ4 +
                   b[5]*lo*arsenic)
print (mean(delta))
```

