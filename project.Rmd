---
title: "The Relationship Between Arsenic Concentrations and Well Usage"
author: "Nagaprasad Rudrapatna and Martin Olarte"
header-includes:
   - \usepackage{setspace}
   - \singlespacing
fig_width: 6.5
fig_height: 4
df_print: kable
output: pdf_document
fontsize: 12pt
mainfont: Times New Roman
sansfont: Times New Roman
monofont: Times New Roman
indent: true
self_contained: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(rstanarm)
library(magrittr)
library(tidyverse)
library(ggplot2)
library(loo)
library(bayesplot)
library(caret)
library(rstan)
library(HSAUR3)
library(foreign)
library(R2OpenBUGS)
library(arm)
library(kableExtra)
```

### Introduction

Araihazar, Bangladesh

Many of the wells used for drinking water in Bangladesh and other South Asian countries are contaminated with natural arsenic, affecting an estimated 100 million people. Arsenic is a cumulative poison, and exposure increases the risk of cancer and other diseases, with risks estimated to be proportional to exposure.
Any locality can include wells with a range of arsenic levels, as can be seen from the map in Figure 5.7 of all the wells in a collection of villages in a small area of Bangladesh. The bad news is that even if your neighbor’s well is safe, it does not mean that yours is safe. However, the corresponding good news is that, if your well has a high arsenic level, you can probably find a safe well nearby to get your water from—if you are willing to walk the distance and your neighbor is willing to share. (The amount of water needed for drinking is low enough that adding users to a well would not exhaust its capacity, and the surface water in this area is subject to
contamination by microbes, hence the desire to use water from deep wells.) In the area shown in Figure 5.7, a research team from the United States and Bangladesh measured all the wells and labeled them with their arsenic level as well as a characterization as “safe” (below 0.5 in units of hundreds of micrograms per liter, the Bangladesh standard for arsenic in drinking water) or “unsafe” (above 0.5). People with unsafe wells were encouraged to switch to nearby private or community wells or to new wells of their own construction. A few years later, the researchers returned to find out who had switched wells. We shall perform a logistic regression analysis to understand the factors predictive
of well switching among the users of unsafe wells. In the notation of the previous section, our outcome variable is

yi = 1 if household i switched to a new well
yi = 0 if household i continued using its own well

We consider the following inputs:

We shall first fit the model just using distance to nearest well and then put in
arsenic concentration, organizational membership, and education.





```{r data}
# Set up cleaned dataset for Bangladesh well-switching

# Read in the data

all <- read.dta ("all.dta", convert.factors=F)

# For simplicity, pull out all wells with missing data in the variables that 
# we will be using in our analysis

# according to well owner's wife/sister-in-law
# survey of laypersons, not scientific experts

missing <- is.na (all[,"func"] + all[,"as"] + all[,"distnearest"] + all[,"assn"]
                  + all[,"ed"] + all[,"ed4"] + all[, "drink"] + all[, "status"]
                  + all[, "change"] + all[, "shifted"])
table(missing)

# with the added predictors, still only 12 missing out of 6510

# recode change and shifted to 0/1

# https://www.ldeo.columbia.edu/~avangeen/publications/documents/vanGeen_JESH_07.pdf

# PREDICTIVE ACCURACY

# try recoding: the levels of education among the 3020 respondents varied from 
# 0 to 18 years, with nearly a third having zero. We repeated our analysis with 
# a discrete recoding of the education variable 
# (0 = 0 years, 1 = 1–8 years, 2 = 9–12 years, 3 = 12+ years), 
# and our results were essentially unchanged. 

# ed4: ed/4 - if ed is not a multiple of 4, ed4 truncates the quotient, 
# e.g. ed = 10, ed4 = 10/4 = 2.5 -> 2 

# perception of well safety; not based on arsenic concentrations 
# (already know that every well in consideration is unsafe) -> see question 6 
# to explain potential biases, source of misinformation

# Include only the wells that are functioning (func==1) - analysis does not 
# consider preferences (switching for no apparent reason related to safety)
# and "unsafe" (as>50) - arsenic concentration micrograms per liter > 50
keep <- all[,"func"]==1 & all[,"as"]>50
attach.all (all[!missing & keep,])

# Give convenient names to the variables

switch <- switch
arsenic <- as 
dist <- distnearest 
assoc <- ifelse (assn > 0, "Yes", "No")
educ <- ed
educ4 <- case_when(ed4 == 0 ~ "0",
                   ed4 == 1 ~ "1-8",
                   ed4 == 2 ~ "9-12",
                   ed4 == 3 ~ "12+")
use <- case_when(drink == 0 ~ "Neither",
                 drink == 1 ~ "Unfrequently",
                 drink == 2 ~ "Drinking",
                 drink == 3 ~ "Cooking",
                 drink == 13 ~ "Cooking",
                 drink == 23 ~ "Both")
status_perceived <- case_when(status == 0 ~ "Unsafe",
                              status == 1 ~ "Safe",
                              status == 2 ~ "Don't Know")
well_shift <- ifelse (shifted == 0, "No", "Yes")

wells.data <- cbind (switch, arsenic, dist, assoc, educ, educ4, use, 
                     status_perceived, well_shift)
write.table (wells.data, "wells.dat")

wells <- read.table("wells.dat", header = TRUE)
df <- data.frame(wells) %>%
  mutate(switch = as.factor(switch),
         assoc = as.factor(assoc),
         educ4 = factor(educ4, levels = c("0", "1-8", "9-12", "12+")),
         use = factor(use, levels = c("Unfrequently", "Drinking", "Cooking", "Both", "Neither")),
         status_perceived = factor(status_perceived, levels = c("Safe", "Unsafe", "Don't Know")),
         well_shift = as.factor(well_shift))

drinkorcook_wells <- wells[wells$use!=0,]
## Stopping point
```

```{r EDA, fig.width = 8, fig.height = 4, echo=FALSE}
# captions

### Continuous Predictors
# Distances 
hist(dist, breaks=seq(0,10+max(dist[!is.na(dist)]),10), 
     xlab="Distance (m) to nearest safe well", ylab="Frequency", 
     main="Distance to Wells")
wells %>%
  summarise(min = min(dist),
            max = max(dist),
            mean = mean(dist), 
            sd = sd(dist), 
            median = median(dist), 
            IQR = IQR(dist)) %>%
  kable(digits = 3)

ggplot(data = df, mapping = aes(x = dist, fill = switch)) +
  geom_density(alpha = 0.6) + labs(x  = "Distance (m) to nearest safe well", y = "Density", 
       title = "Distance to Wells")
    
# Arsenic 
hist(arsenic, breaks=seq(0,100+max(arsenic[!is.na(arsenic)]),50), 
     xlab="Arsenic Content (micrograms per liter)", ylab="Frequency", main="Arsenic Content")
wells %>%
  summarise(min = min(arsenic),
            max = max(arsenic),
            mean = mean(arsenic), 
            sd = sd(arsenic), 
            median = median(arsenic), 
            IQR = IQR(arsenic)) %>%
  kable(digits = 3)

ggplot(data = df, mapping = aes(x = arsenic, fill = switch)) +
  geom_density(alpha = 0.6) +
  labs(x  = "Arsenic Content (micrograms per liter)", y = "Density", 
       title = "Arsenic Content")
    
### Discrete Predictors
# Education 
hist(educ, breaks=seq(0,5+max(educ[!is.na(educ)]),5), xlab="Years of Education",
     ylab="Frequency", main="Education")
wells %>%
  summarise(min = min(educ),
            max = max(educ),
            mean = mean(educ), 
            sd = sd(educ), 
            median = median(educ), 
            IQR = IQR(educ)) %>%
  kable(digits = 3)
ggplot(data = df, mapping = aes(x = educ, fill = switch)) +
  geom_histogram(binwidth = 1) +
  labs(x  = "Years of Education", y = "Frequency", 
       title = "Education")
# Education (Recoded)
ggplot(data = df, mapping = aes(x = educ4, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Years of Education", y = "Frequency", 
       title = "Education (Recoded)")

# Community Association
ggplot(data = df, mapping = aes(x = assoc, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Community Association", y = "Frequency", 
       title = "Community Association")
# Use
ggplot(data = df, mapping = aes(x = use, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Well Use", y = "Frequency", 
       title = "Well Use")

# Perceived Status
ggplot(data = df, mapping = aes(x = status_perceived, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Perceived Status", y = "Frequency", 
       title = "Perceived Status")

# Shift
ggplot(data = df, mapping = aes(x = well_shift, fill = switch)) +
  geom_bar(position = "stack") + 
  labs (x = "Well Shift (Last 3 Years)", y = "Frequency", 
       title = "Well Shift (Last 3 Years)")

### Response Variable
ggplot(data = df, mapping = aes(x = switch)) +
  geom_bar(fill = "dark green") + 
  labs (x = "Well Switch*", y = "Frequency",
        caption = "*0 = No,  1 = Yes",
        title = "Well Switch (Response)")
```

- arsenic concentration: all > 50 based on structure of problem; max: 965 micrograms per liter which is almost 20x the safe concentration threshold (justifies why this is even an issue that needs to be urgently addressed); seems that arsenic content is less of a significant predictor than perceived well status and distance to nearest safe well (interaction with perceived well status could be relevant as perhaps households decide whether to switch based on a combination of perceptions and science; interaction with distance: wells that are far from the nearest safe well are also likely to be particularly high in arsenic)

- community association vs. switch: the relative proportions of switch/no switch seem consistent regardless of community association; evidence in the data suggests community association is insignificant (still include in initial model before model selection to confirm our EDA observations are supported)

- continuous education histogram: clear trend, low levels of education most prevalent among population

- years of education vary greatly among households; majority either have no formal education or five years; difficult to determine if there is a significant effect since some of the levels have little observations -> motivates recoding

- recoded education: as expected, 0 years is still most frequent; the overall population of interest has between 0-12 years of education (up to high school); 12+ (tertiary education) seems to be a luxury; among those who have 12+ years in education, most did not choose to switch - is this because of well use? (interaction with well use justified)

- well use with switch: the vast majority of households use wells for both drinking and cooking, or neither; those who do not use wells for drinking and cooking, as expected, responded they would switch most frequently; those who used wells for both mostly did not choose to switch -> well use significant predictor

- the univariate distribution of distances confirms our initial suspicions about the proximity of safe and unsafe wells. It is clear that safe and unsafe wells are intermingled in most of the area, which suggests that users of unsafe wells can switch to nearby safe wells; summary stats tell us that the maximum distance to the nearest safe (define earlier) well is 339.531 meters (which is reasonable for daily round trips (double distance); assume speed 1 m/s, then roughly 340 s ~ 5.7 min) and the average distance is 48.332 m (interaction with well use, well purpose determines frequency of use and daily travel time; interaction with perceived status, maybe households did not switch even with small distances due to misassessment of risk)

- since the densities do not exactly align, there is evidence in the data that distance to the nearest safe well is not the only significant covariate; there is a noticeable difference in the propensity of households to switch when the distance to the nearest safe well is between 0-200 m; at the tails (i.e. when the distance exceeds 230 or so, the densities overlap); switching occurs with greatest probability when distance to nearest safe well is between 0-50 m

- based on the plot of well shift in the last 3 years and the response, there is evidence in the data suggesting that this covariate should be significant in the logistic regression model; note that all of the households which shifted to a different well in the past three years, expected to switch once more when informed about the unsafe well (interaction with distance to safest well; maybe some sections of the region have more unsafe wells than others, so frequent shifting is best practice)
- 1283 - no switch
- 1737 - switch
although there are a lot of 0's, the data is not unbalanced (no cloglog regression)

- based on the plot of perceived well status and the response, there is evidence in the data suggesting that this covariate should be significant in the logistic regression model (seemingly significant differences, at least visually, among levels of predictor); note that a significant proportion of households who believed the well to be unsafe, still chose not to switch (interaction with well use; if not using for cooking and/or drinking, the standard for cleanliness may be lower in people's minds; interaction with education: people's beliefs and perceptions are shaped by their experiences; lack of formal education may indicate a lack of appreciation for science and lead to misassessment of risk)


# Modeling 

It seems more reasonable to rescale distance in 100-meter units for interpretability since the regression coefficient associated with a 1-meter change in distance to the nearest safe well can be misleading, e.g. the coefficient may correspond to the difference between a house located 100 meters away from the nearest safe well and a house located 101 meters away (a negligible difference in practice).

Before fitting interactions it
makes sense to mean-center the input variables so that we can more easily interpret the
coefficients. We do not fully standardize these—that is, we do not scale by their standard
deviations—because it is convenient to be able to consider known differences on the
original scales of the data (100-meter distances and arsenic-concentration units).

Now, we will provide a more technical description of our modeling framework. We decided to fit the following generalized linear model:


Finally, we found that placing independent t-distribution priors on the regression coefficients is appropriate when developing data-driven (weakly-informative prior) logistic regression models. Specifically, we decided to use t-distributions with 7 degrees of freedom and a scale of 2.5. These hyperparameters were chosen after considering the null logistic regression model, i.e. intercept-only model. Gellman and colleagues explain that this baseline case (one-half of a success and one-half of a failure for a single Binomial trial with probability $p=\text{logit}^{-1}(\theta)$) has a corresponding likelihood of $\text{e}^{\theta/2} / (1+e^{\theta})$ and further that the density function associated with the t-distribution (with 7 degrees of freedom and scale 2.5) is a reasonable approximation. It is appropriate to use a weakly-informative prior distribution because the objective is to develop a data-driven model with high predictive accuracy (and we did not find any context-specific information which would restrict the prior distribution).



- Main effects: dist100, arsenic, educ4, assoc, use, status_perceived, well_shift
- Interaction terms: arsenic:status_perceived, arsenic:dist, educ4:use, dist100:use, dist100:status_perceived, well_shift:dist100, status_perceived:use, status_perceived:educ4


```{r}
# Andrew Gelman, Aleks Jakulin, Maria Grazia Pittau and Yu-Sung Su. (2009). “A Weakly Informative Default Prior Distribution For Logistic And Other Regression Models.” The Annals of Applied Statistics 2 (4): 1360--1383. http://www.stat.columbia.edu/~gelman/research/published/priors11.pdf

# Scaling & Centering
wells$dist100 <- wells$dist/100

wells$dist100 <- scale(wells$dist100, scale = FALSE)
wells$arsenic <- scale(wells$arsenic, scale = FALSE)


seed <- 200

fit.1 <- bayesglm(switch ~ dist, data = wells,
                 family = binomial(link = "logit"), 
                 prior = normal(0,1), prior_intercept = normal(0,1),
                 seed = seed,
                 refresh = 0)

print(fit.1$stanfit)

# Redefine distance in 100-meter units and fit the model again

dist100 <- dist/100
fit.2 <- stan_glm(switch ~ dist100, data = wells,
                 family = binomial(link = "logit"), 
                 prior = normal(0,1), prior_intercept = normal(0,1),
                 seed = seed,
                 refresh = 0)

print(fit.2$stanfit)

### END OF EDITED CODE

# plots of model fit

jitter.binary <- function(a, jitt=.05){
  a + (1-2*a)*runif(length(a),0,jitt)
}

#postscript ("c:/books/multilevel/arsenic.logitfit.1new.a.ps", height=3.5, width=4, horizontal=TRUE)
#plot(c(0,max(dist, na.rm=TRUE)*1.02), c(0,1), xlab="Distance (in meters) to nearest safe well", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
#curve (invlogit(coef(fit.1)[1]+coef(fit.1)[2]*x), lwd=1, add=TRUE)
#points (dist, jitter.binary(switch), pch=20, cex=.1)
#dev.off ()

# histogram of As levels

#postscript ("c:/books/multilevel/arsenic.levels.a.ps", height=3, width=4, horizontal=TRUE)
hist (arsenic, breaks=seq(0,.25+max(arsenic[!is.na(arsenic)]),.25), freq=TRUE, xlab="Arsenic concentration in well water", ylab="", main="", mgp=c(2,.5,0))
#dev.off ()

# model with 2 predictors

fit.3 <- glm (switch ~ dist100 + arsenic, family=binomial(link="logit"))
display (fit.3)

#postscript ("c:/books/multilevel/arsenic.2variables.a.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(dist,na.rm=TRUE)*1.02), c(0,1), xlab="Distance (in meters) to nearest safe well", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (dist, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.3)[1]+coef(fit.3)[2]*x/100+coef(fit.3)[3]*.50), lwd=.5, add=TRUE)
curve (invlogit(coef(fit.3)[1]+coef(fit.3)[2]*x/100+coef(fit.3)[3]*1.00), lwd=.5, add=TRUE)
text (50, .27, "if As = 0.5", adj=0, cex=.8)
text (75, .50, "if As = 1.0", adj=0, cex=.8)
#dev.off ()

#postscript ("c:/books/multilevel/arsenic.2variables.b.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(arsenic,na.rm=TRUE)*1.02), c(0,1), xlab="Arsenic concentration in well water", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (arsenic, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.3)[1]+coef(fit.3)[2]*0+coef(fit.3)[3]*x), from=0.5, lwd=.5, add=TRUE)
curve (invlogit(coef(fit.3)[1]+coef(fit.3)[2]*0.5+coef(fit.3)[3]*x), from=0.5, lwd=.5, add=TRUE)
text (50, .78, "if dist = 0", adj=0, cex=.8)
text (200, .6, "if dist = 50", adj=0, cex=.8)
#dev.off ()

# including an interaction

fit.4 <- glm (switch ~ dist100 + arsenic + dist100:arsenic,
  family=binomial(link="logit"))

# centering the input variables

c.dist100 <- dist100 - mean (dist100)
c.arsenic <- arsenic - mean (arsenic)

fit.5 <- glm (switch ~ c.dist100 + c.arsenic + c.dist100:c.arsenic,
  family=binomial(link="logit"))

#postscript ("c:/books/multilevel/arsenic.interact.a.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(dist,na.rm=TRUE)*1.02), c(0,1), xlab="Distance (in meters) to nearest safe well", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (dist, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.4)[1]+coef(fit.4)[2]*x/100+coef(fit.4)[3]*.50+coef(fit.4)[4]*(x/100)*.50), lwd=.5, add=TRUE)
curve (invlogit(coef(fit.4)[1]+coef(fit.4)[2]*x/100+coef(fit.4)[3]*1.00+coef(fit.4)[4]*(x/100)*1.00), lwd=.5, add=TRUE)
text (50, .29, "if As = 0.5", adj=0, cex=.8)
text (75, .50, "if As = 1.0", adj=0, cex=.8)
#dev.off ()

#postscript ("c:/books/multilevel/arsenic.interact.b.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(arsenic,na.rm=TRUE)*1.02), c(0,1), xlab="Arsenic concentration in well water", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (arsenic, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.4)[1]+coef(fit.4)[2]*0+coef(fit.4)[3]*x+coef(fit.4)[4]*0*x), from=0.5, lwd=.5, add=TRUE)
curve (invlogit(coef(fit.4)[1]+coef(fit.4)[2]*0.5+coef(fit.4)[3]*x+coef(fit.4)[4]*0.5*x), from=0.5, lwd=.5, add=TRUE)
text (.50, .78, "if dist = 0", adj=0, cex=.8)
text (2.00, .6, "if dist = 50", adj=0, cex=.8)
#dev.off ()

# adding social predictors

educ4 <- educ/4

fit.6 <- glm (switch ~ c.dist100 + c.arsenic + c.dist100:c.arsenic +
  assoc + educ4, family=binomial(link="logit"))
display (fit.6)

fit.7 <- glm (switch ~ c.dist100 + c.arsenic + c.dist100:c.arsenic +
  educ4, family=binomial(link="logit"))
display (fit.7)

c.educ4 <- educ4 - mean(educ4)

fit.8 <- glm (switch ~ c.dist100 + c.arsenic + c.educ4 + c.dist100:c.arsenic +
  c.dist100:c.educ4 + c.arsenic:c.educ4, family=binomial(link="logit"))
display (fit.8)

# plots of residuals

pred.8 <- fit.8$fitted.values

#postscript ("c:/books/multilevel/arsenic.logitresidsa.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,1), c(-1,1), xlab="Estimated  Pr (switching)", ylab="Observed - estimated", type="n", main="Residual plot", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
points (pred.8, switch-pred.8, pch=20, cex=.2)
#dev.off ()

binned.resids <- function (x, y, nclass=sqrt(length(x))){
  breaks.index <- floor(length(x)*(1:(nclass-1))/nclass)
  breaks <- c (-Inf, sort(x)[breaks.index], Inf)
  output <- NULL
  xbreaks <- NULL
  x.binned <- as.numeric (cut (x, breaks))
  for (i in 1:nclass){
    items <- (1:length(x))[x.binned==i]
    x.range <- range(x[items])
    xbar <- mean(x[items])
    ybar <- mean(y[items])
    n <- length(items)
    sdev <- sd(y[items])
    output <- rbind (output, c(xbar, ybar, n, x.range, 2*sdev/sqrt(n)))
  }
  colnames (output) <- c ("xbar", "ybar", "n", "x.lo", "x.hi", "2se")
  return (list (binned=output, xbreaks=xbreaks))
}

#postscript ("c:/books/multilevel/arsenic.logitresidsb.ps", height=3.5, width=4, horizontal=TRUE)
br.8 <- binned.resids (pred.8, switch-pred.8, nclass=40)$binned
plot(range(br.8[,1]), range(br.8[,2],br.8[,6],-br.8[,6]), xlab="Estimated  Pr (switching)", ylab="Average residual", type="n", main="Binned residual plot", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
lines (br.8[,1], br.8[,6], col="gray", lwd=.5)
lines (br.8[,1], -br.8[,6], col="gray", lwd=.5)
points (br.8[,1], br.8[,2], pch=20, cex=.5)
#dev.off ()

# compute error rates

error.rate <- mean(round(abs(switch-pred.8)))
error.rate.null <- mean(round(abs(switch-mean(pred.8))))

# more residual plots

#postscript ("c:/books/multilevel/arsenic.logitresids.2a.ps", height=3.5, width=4, horizontal=TRUE)
br <- binned.resids (dist, switch-pred.8, nclass=40)$binned
plot(range(br[,1]), range(br[,2],br[,6],-br[,6]), xlab="Distance to nearest safe well", ylab="Average residual", type="n", main="Binned residual plot", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
n.within.bin <- length(y)/nrow(br)
lines (br[,1], br[,6], col="gray", lwd=.5)
lines (br[,1], -br[,6], col="gray", lwd=.5)
points (br[,1], br[,2], pch=20, cex=.5)
#dev.off ()

#postscript ("c:/books/multilevel/arsenic.logitresids.2b.ps", height=3.5, width=4, horizontal=TRUE)
br <- binned.resids (arsenic, switch-pred.8, nclass=40)$binned
plot(range(0,br[,1]), range(br[,2],br[,6],-br[,6]), xlab="Arsenic level", ylab="Average residual", type="n", main="Binned residual plot", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
lines (br[,1], br[,6], col="gray", lwd=.5)
lines (br[,1], -br[,6], col="gray", lwd=.5)
points (br[,1], br[,2], pch=20, cex=.5)
#dev.off ()

# new model on log scale

log.arsenic <- log (arsenic)
c.log.arsenic <- log.arsenic - mean (log.arsenic)

fit.9 <- glm (switch ~ c.dist100 + c.log.arsenic + c.educ4 +
  c.dist100:c.log.arsenic + c.dist100:c.educ4 + c.log.arsenic:c.educ4,
  family=binomial(link="logit"))
display (fit.9)

fit.9a <- glm (switch ~ dist100 + log.arsenic + educ4 +
  dist100:log.arsenic + dist100:educ4 + log.arsenic:educ4,
  family=binomial(link="logit"))

# graphs for log model

#postscript ("c:/multilevel/arsenic.logmodel.ps", height=3.5, width=4, horizontal=TRUE)
plot(c(0,max(arsenic,na.rm=TRUE)*1.02), c(0,1), xlab="Arsenic concentration in well water", ylab="Pr (switching)", type="n", xaxs="i", yaxs="i", mgp=c(2,.5,0))
points (arsenic, jitter.binary(switch), pch=20, cex=.1)
curve (invlogit(coef(fit.9a)[1]+coef(fit.9a)[2]*0+coef(fit.9a)[3]*log(x)+coef(fit.9a)[4]*mean(educ4)+coef(fit.9a)[5]*0*log(x)+coef(fit.9a)[6]*0*mean(educ4)+coef(fit.9a)[7]*log(x)*mean(educ4)), from=.50, lwd=.5, add=TRUE)
curve (invlogit(coef(fit.9a)[1]+coef(fit.9a)[2]*.5+coef(fit.9a)[3]*log(x)+coef(fit.9a)[4]*mean(educ4)+coef(fit.9a)[5]*.5*log(x)+coef(fit.9a)[6]*.5*mean(educ4)+coef(fit.9a)[7]*log(x)*mean(educ4)), from=.50, lwd=.5, add=TRUE)
text (.25, .80, "if dist = 0", adj=0, cex=.8)
text (2.00, .63, "if dist = 50", adj=0, cex=.8)
#dev.off ()

pred.9 <- fit.9$fitted.values

#postscript ("c:/books/multilevel/arsenic.logitresids.3b.ps", height=3.5, width=4, horizontal=TRUE)
br <- binned.resids (arsenic, switch-pred.9, nclass=40)$binned
plot(range(0,br[,1]), range(br[,2],br[,6],-br[,6]), xlab="Arsenic level", ylab="Average residual", type="n", main="Binned residual plot\nfor model with log (arsenic)", mgp=c(2,.5,0))
abline (0,0, col="gray", lwd=.5)
n.within.bin <- length(y)/nrow(br)
lines (br[,1], br[,6], col="gray", lwd=.5)
lines (br[,1], -br[,6], col="gray", lwd=.5)
points (br[,1], br[,2], pch=20, cex=.5)
#dev.off ()

# calculations for average predictive differences

# simple model
fit.10 <- glm (switch ~ dist100 + arsenic + educ4,
  family=binomial(link="logit"))
display (fit.10)

# avg pred diffs for distance to nearest safe well
b <- coef (fit.10)
hi <- 1
lo <- 0
delta <- invlogit (b[1] + b[2]*hi + b[3]*arsenic + b[4]*educ4) -
         invlogit (b[1] + b[2]*lo + b[3]*arsenic + b[4]*educ4)
print (mean(delta))

# avg pred diffs for arsenic level
hi <- 1.0
lo <- 0.5
delta <- invlogit (b[1] + b[2]*dist100 + b[3]*hi + b[4]*educ4) -
         invlogit (b[1] + b[2]*dist100 + b[3]*lo + b[4]*educ4)
print (mean(delta))

# avg pred diffs for education
hi <- 3
lo <- 0
delta <- invlogit (b[1]+b[2]*dist100+b[3]*arsenic+b[4]*hi) -
         invlogit (b[1]+b[2]*dist100+b[3]*arsenic+b[4]*lo)
print (mean(delta))

# example model with interaction
fit.11 <- glm (switch ~ dist100 + arsenic + educ4 + dist100:arsenic,
  family=binomial(link="logit"))
display (fit.11)

b <- coef (fit.11)
hi <- 1
lo <- 0
delta <- invlogit (b[1] + b[2]*hi + b[3]*arsenic + b[4]*educ4 +
                   b[5]*hi*arsenic) -
         invlogit (b[1] + b[2]*lo + b[3]*arsenic + b[4]*educ4 +
                   b[5]*lo*arsenic)
print (mean(delta))
```

